5/7/21

A long time ago, I read an article about someone who *bred* programs on their
dev machine. They reproduced sexually and eventually eventually evolved ways to
kill each other off.

In nature, organisms need to use energy, maintain homeostasis, and
reproduce. All three criteria can be considered to be met a standard computer
program.

However, they don't generally change, nor do they generally have an instinct to
reproduce themselves as much as possible.

We'll need to create a framework in which for these digital organisms to live.
Let's give them a rudimentary task to perform. They'll need to do it as quickly
as possible and submit the answer. The input will be written into the process's
address space before it is started and it will be expected to write the output
to a particular location when it exits.

A parent process will manage many of these organisms. It will start N of them
for each generation, allowing them to run concurrently. The top M will be bred
together to form the next generation.

We'll start with a simple task and ensure that there are degrees of success to
the task.

Okay, so I'm thinking about the method of communication between the parent and
the child. Shared memory is by far the simples method to use. Unfortunately, a
fork+exec wouldn't work because the exec would wipe out the shared memory.

So what if I didn't use exec? We wouldn't package each organism as an ELF.
Instead, it would just be a "function". The environment would read each genome
in a different thread in the environment process. Each thread would wait on a
wait group for them all to finish, then, all at once, we'd jump to the first
instruction in the genome. Once the task is finished, the organism must signal
the environment that it is finished. A manager thread will notice that the
organism has finished and record the result.

How about this? What if we have a separate concurrent process (or thread?)
monitoring the output of each organism. If it has not made sufficient progress
on its task, then the this god process kills the organism. This God process
would need to be memory protected from the organisms so that they couldn't just
learn how to kill *it*.

Okay, I'm finding it easier to write the initial organism in assembly. It gives
me much more precise control over what appears in the genome.

Okay, now I've got the ability to load in a buffer of executable code and run
it, passing in a single quadword of data.

I think the next step is going to be giving it a buffer to work with. Should we
protect it?  I don't think so. Getting to mess around with other things within
the process will allow us to simulate competition between organisms.

So what will the initial task be? We want something where we can create an
initial suboptimal solution and that can then be gradually evolved to a more
optimal solution. Later on, we'll also want to incorporate some sense of the
energy expended in reaching that conclusion. So how will the environment
determine that? We could use wall clock time, but this requires large stretches
of time. It looks like we can get per-thread CPU usage from the OS. This will
allow us to figure out exactly how much CPU time has been used. This will be
given to us in "clock ticks", which are quite accurate.

The first thought I had was multiplying two numbers together. We can start out
by implementing it as a loop, 8-bit style. Then we hope that, by mutation, we
get a multiplication opcode. Unfortunately, this seems like it would require a
bit of an evolutionary leap. Would we *ever* get there?

Maybe something even simpler. How about calculating 2*(a + b) and we start off
by giving it just a + b? Seems reasonable. So what should the byte layout look
like?

How about something nice and simple. One byte for a, one byte for b, and a third
byte will be the output.

Okay, what about the concurrency model? So far, we've had two ideas. The first
is a more traditional evolutionary algorithm. We run a generation for a fixed
period of time, evaluate its fitness, and then have the environment do the
reproduction. Not the most realistic.

The more realistic option is to encode reproduction into the genome itself. So
the model here becomes.

1. Environment starts a thread, loads a genome, and starts an organism. From
   that point on, the thread belongs to the organism.
2. Periodically, the environment inspects the organism's shared memory. If it
   hasn't been completely enough tasks well enough, it is killed off.
3. The organism never terminates. If it does, this is considered a failure to
   maintain homeostasis. It divides its time between completing the task and
   reproducing.

Okay, so completing computational tasks seems pretty straightforward. But how
does *sexual reproduction* happen? Each organism would have to know how to
introspect itself and produce a gene sequence. Then, we'd have to have males and
females or all hermaphrodites. A male would have to somehow identify a partner and
somehow send that gene sequence to that partner. Then, the female would have to
recombine those two gene sequences into a single gene sequence. Finally, we
would have to instantiate a *new organism* from that gene sequence. How would we
even orchestrate that? They'd have to spawn a new thread and it would have to
somehow be noticed by the managing thread. Very complicated stuff.

Maybe for the moment we just stick to mitosis.
